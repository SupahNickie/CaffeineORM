package supahnickie.caffeine;

import java.sql.PreparedStatement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * CaffeineChainable instances are used to allow ActiveRecord style method chaining in order to generate SQL in an easier manner.
 * Functions are called one after the other until your lookup is built, then the query is called using the execute() command.
 * 
 * @author Nicholas Case (nicholascase@live.com)
 * @version 5.0.0
 * @see <a href="https://github.com/SupahNickie/CaffeineORM/blob/master/README.md">README containing examples</a>
 * @see <a href="https://github.com/rails/rails/tree/master/activerecord">ActiveRecord, the inspiration for this project</a>
 */
public final class CaffeineChainable {
	String currentQuery;
	boolean firstCondition;
	List<Object> placeholders = new ArrayList<Object>();

	public CaffeineChainable() throws Exception {
		resetQueryState();
	}

	/**
	 * Executes the SQL generated by the combination of the prior chainable statements.
	 * @return List of CaffeineObjects populated with data from the database. The return is always a list, even when there is only one record.
	 * @throws Exception
	 */
	@SuppressWarnings("unchecked")
	public final List<CaffeineObject> execute() throws Exception {
		String sql = getCurrentQuery();
		PreparedStatement ps = CaffeineConnection.setup().prepareStatement(sql);
		int counter = 1;
		for (int i = 0; i < getPlaceholders().size(); i++) {
			List<Object> arrayArgs = (List<Object>) getPlaceholders().get(i);
			for (int j = 0; j < arrayArgs.size(); j++) {
				ps.setObject(counter, arrayArgs.get(j));
				counter++;
			}
		}
		List<CaffeineObject> results = CaffeineSQLRunner.executeQuery(ps);
		resetQueryState();
		return results;
	}

	/**
	 * Generates a SQL snippet used to join two tables together. More complex queries wishing to return attributes from
	 * more than one table should make use of the rawQuery method in the CaffeineConnection class instead. A call 
	 * of join("left outer", "users.id", "downloads.org_id") would generate the SQL "(...) left outer join downloads on 
	 * downloads.org_id = users.id"
	 * @param typeOfJoin Examples are "inner", "left outer", "full", etc.
	 * @param fromJoin Table.foreignKey to use when specifying which table you're joining from. Example: "users.id"
	 * @param toJoin Table.foreignKey to use when specifying which table you're joining to. Example: "downloads.org_id"
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 * @see {@link CaffeineConnection#rawQuery(String)} CaffeineConnection#rawQuery(String) for more complex queries
	 */
	public final CaffeineChainable join(String typeOfJoin, String fromJoin, String toJoin) throws Exception {
		String[] fromJoins = fromJoin.split("\\.");
		String[] toJoins = toJoin.split("\\.");
		String sql;
		sql = (getCurrentQuery() == null) ? CaffeineObject.baseQuery() : getCurrentQuery();
		typeOfJoin = (typeOfJoin.equals("")) ? "join " : typeOfJoin + " join ";
		sql = sql + " " + typeOfJoin + toJoins[0] + " on " + toJoins[0] + "." + toJoins[1] + " = " + fromJoins[0] + "." + fromJoins[1];
		setCurrentQuery(sql);
		return this;
	}

	/**
	 * Generates a SQL snippet used to join two tables together. More complex queries wishing to return attributes from
	 * more than one table should make use of the rawQuery method in the CaffeineConnection class instead. A call 
	 * of join("users.id", "downloads.org_id") would generate the SQL "(...) join downloads on 
	 * downloads.org_id = users.id"
	 * @param fromJoin Table.foreignKey to use when specifying which table you're joining from. Example: "users.id"
	 * @param toJoin Table.foreignKey to use when specifying which table you're joining to. Example: "downloads.org_id"
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 * @see {@link CaffeineConnection#rawQuery(String)} CaffeineConnection#rawQuery(String) for more complex queries
	 */
	public final CaffeineChainable join(String fromJoin, String toJoin) throws Exception {
		return join("", fromJoin, toJoin);
	}

	/**
	 * Adds a "where" condition to further limit the scope of the query's return. Multiple "where" calls
	 * act as "and" conditions.
	 * @param condition Raw SQL with no placeholders
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 */
	public final CaffeineChainable where(String condition) throws Exception {
		return appendCondition("and", condition);
	}

	/**
	 * Adds a "where" condition to further limit the scope of the query's return. Multiple "where" calls
	 * act as "and" conditions. This version of the function signature expects JDBC style placeholders (?)
	 * to be used.
	 * @param condition Raw SQL (with ? placeholders)
	 * @param args Varargs of type Object to replace placeholders with
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 */
	public final CaffeineChainable where(String condition, Object... args) throws Exception {
		getPlaceholders().add(Arrays.asList(args));
		return where(condition);
	}

	/**
	 * Adds a "where" condition to further limit the scope of the query's return. Multiple "where" calls
	 * act as "and" conditions. This version of the function signature expects JDBC style placeholders (?)
	 * to be used.
	 * @param condition Raw SQL (with ? placeholders)
	 * @param args List containing type Object to replace placeholders with
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 */
	public final CaffeineChainable where(String condition, List<Object> args) throws Exception {
		getPlaceholders().add(args);
		return where(condition);
	}

	/**
	 * Adds an "or" condition to broaden the scope of the query's return.
	 * @param condition Raw SQL with no placeholders
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 */
	public final CaffeineChainable or(String condition) throws Exception {
		return appendCondition("or", condition);
	}

	/**
	 * Adds an "or" condition to broaden the scope of the query's return. This version 
	 * of the function signature expects JDBC style placeholders (?) to be used.
	 * @param condition Raw SQL (with ? placeholders)
	 * @param args Varargs of type Object to replace placeholders with
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 */
	public final CaffeineChainable or(String condition, Object... args) throws Exception {
		getPlaceholders().add(Arrays.asList(args));
		return or(condition);
	}

	/**
	 * Adds an "or" condition to broaden the scope of the query's return. This version 
	 * of the function signature expects JDBC style placeholders (?) to be used.
	 * @param condition Raw SQL (with ? placeholders)
	 * @param args List containing type Object to replace placeholders with
	 * @return The same instance of CaffeineChainable that you may continue using to build a query with.
	 * @throws Exception
	 */
	public final CaffeineChainable or(String condition, List<Object> args) throws Exception {
		getPlaceholders().add(args);
		return or(condition);
	}

	private final CaffeineChainable appendCondition(String type, String condition) throws Exception {
		if (getCurrentQuery() == null) {
			setCurrentQuery(CaffeineObject.baseQuery());
		}
		Pattern p = Pattern.compile("where");
		Matcher m = p.matcher(getCurrentQuery());
		if ( !m.find() ) setFirstCondition(true);
		if ( getFirstCondition() ) {
			setCurrentQuery(getCurrentQuery() + " where ");
		} else {
			setCurrentQuery(getCurrentQuery() + type + " ");
		}
		setFirstCondition(false);
		setCurrentQuery(getCurrentQuery() + condition + " ");
		return this;
	}

	private final void resetQueryState() throws Exception {
		setPlaceholders(new ArrayList<Object>());
		setCurrentQuery(null);
		setFirstCondition(true);
	}

	/* Getters */

	final List<Object> getPlaceholders() throws Exception {
		return this.placeholders;
	}

	final String getCurrentQuery() throws Exception {
		return this.currentQuery;
	}

	final boolean getFirstCondition() throws Exception {
		return this.firstCondition;
	}

	/* Setters */

	final void setPlaceholders(List<Object> placeholders) throws Exception {
		this.placeholders = placeholders;
	}

	final void setCurrentQuery(String sql) throws Exception {
		this.currentQuery = sql;
	}

	final void setFirstCondition(Boolean bool) throws Exception {
		this.firstCondition = bool;
	}

}